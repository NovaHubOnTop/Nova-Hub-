--Webhook
  -- sync request
local req = http_request or request or (syn and syn.request)

-- Lite Hub webhook for the muscle legends version not the legends of speed lmao
local webhookUrl = "https://discord.com/api/webhooks/1339680221531734078/14oHrH0WPs7nNsTmmpFyvN554waU8XGNCiHg2p6-6hgooE2uujpsNxKB_UhwhCx3xnu4"

-- roblox services 
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local MarketplaceService = game:GetService("MarketplaceService")
local UserInputService = game:GetService("UserInputService")

-- local player information like the device they are on while using Lite Hub
local player = Players.LocalPlayer
local username = player.Name
local userId = player.UserId
local displayName = player.DisplayName
local deviceType = UserInputService.TouchEnabled and "Mobile" or "PC"

-- which executors will say if they are using them
local function detectExecutor()
    if syn then
        return "Synapse X"
    elseif iskrnlclosure then
        return "KRNL"
    elseif fluxus then
        return "Fluxus"
    elseif Arceus then
        return "Arceus X"
    elseif delta then
        return "Delta"
    elseif codex then
        return "Code X"
    elseif cubix then
        return "Cubix"
    elseif nezur then
        return "Nezur"
    elseif getexecutorname then
        return getexecutorname()  -- For executors that may have this function
    elseif identifyexecutor then
        return identifyexecutor()  -- Another alternative
    else
        return "Unknown Executor"
    end
end

local executor = detectExecutor()

-- the things that will be sent to the discord
local body = {
    embeds = {{
        title = MarketplaceService:GetProductInfo(game.PlaceId).Name,
        description = "Username = " .. username ..
                      "\nUserID = " .. userId ..
                      "\nDisplay Name = " .. displayName ..
                      "\nDevice Type = " .. deviceType ..
                      "\nExecutor = " .. executor,
        color = 0,
        author = { name = "Nova Hub Webhook" }
    }}
}

-- encode the data as JSON
local jsonData = HttpService:JSONEncode(body)

-- send the persons things to discord
req({
    Url = webhookUrl,
    Method = 'POST',
    Headers = { ['Content-Type'] = 'application/json' },
    Body = jsonData
})






--Main Script
local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/Marwanleprodu91670/muscle-legend-lite-hub-elerium-library-/refs/heads/main/library", true))()

local window = library:AddWindow("Nova Hub V1 Free Version | Encrypted Script", {
    main_color = Color3.fromRGB(75,0,130), -- Color
    min_size = Vector2.new(700, 640), -- Size of the gui
    can_resize = false, -- true or false
})

local Client = window:AddTab("Client")
Client:AddLabel("Local Player")

Client:AddButton("Hide Pets",function()
	local args = {
    [1] = "hidePets"
}

game:GetService("ReplicatedStorage"):WaitForChild("rEvents"):WaitForChild("showPetsEvent"):FireServer(unpack(args))

end)


-- Set Size 2
Client:AddButton("Set Size nan", function()
    local args = {
        [1] = "changeSize",
        [2] = "nan"
    }

    game:GetService("ReplicatedStorage"):WaitForChild("rEvents"):WaitForChild("changeSpeedSizeRemote"):InvokeServer(unpack(args))
end)

Client:AddButton("Set Size 2", function()
    local args = {
        [1] = "changeSize",
        [2] = "2"
    }

    game:GetService("ReplicatedStorage"):WaitForChild("rEvents"):WaitForChild("changeSpeedSizeRemote"):InvokeServer(unpack(args))
end)

local selectedWalkSpeed = 16 -- Default WalkSpeed value
local selectedJumpPower = 50 -- Default JumpPower value

-- TextBox to enter WalkSpeed
Client:AddTextBox("Set WalkSpeed", function(text)
    local walkSpeedValue = tonumber(text) -- Convert text to a number

    if walkSpeedValue and walkSpeedValue >= 1 and walkSpeedValue <= 500 then
        selectedWalkSpeed = walkSpeedValue -- Store the valid WalkSpeed
    end
end)

-- Toggle to apply WalkSpeed
Client:AddSwitch("Apply WalkSpeed", function(bool)
    if bool then
        local player = game:GetService("Players").LocalPlayer
        if player and player.Character and player.Character:FindFirstChild("Humanoid") then
            player.Character.Humanoid.WalkSpeed = selectedWalkSpeed
        end
    end
end)

-- TextBox to enter JumpPower
Client:AddTextBox("Set JumpPower", function(text)
    local jumpPowerValue = tonumber(text) -- Convert text to a number

    if jumpPowerValue and jumpPowerValue >= 1 and jumpPowerValue <= 500 then
        selectedJumpPower = jumpPowerValue -- Store the valid JumpPower
    end
end)



-- Toggle to apply JumpPower
Client:AddSwitch("Apply JumpPower", function(bool)
    if bool then
        local player = game:GetService("Players").LocalPlayer
        if player and player.Character and player.Character:FindFirstChild("Humanoid") then
            player.Character.Humanoid.JumpPower = selectedJumpPower
        end
    end
end)

local selectedSize = 2 -- Default size value

-- TextBox to enter the size
Client:AddTextBox("Set Size", function(text)
    local sizeValue = tonumber(text) -- Convert text to a number
    
    if sizeValue and sizeValue >= 1 and sizeValue <= 100 then
        selectedSize = sizeValue -- Store the valid size
    end
end)

-- Toggle to apply the size change
Client:AddSwitch("Apply Size", function(bool)
    if bool then
        -- Validate that ReplicatedStorage and the event exist
        local replicatedStorage = game:GetService("ReplicatedStorage")
        local rEvents = replicatedStorage:FindFirstChild("rEvents")
        local remoteEvent = rEvents and rEvents:FindFirstChild("changeSpeedSizeRemote")

        if remoteEvent and remoteEvent:IsA("RemoteFunction") then
            pcall(function()
                remoteEvent:InvokeServer("changeSize", selectedSize)
            end)
        end
    end
end)

local Maintab = window:AddTab("Main")

-- Anti Crash Button
Maintab:AddButton("Anti Crash", function()
    wait(0.5)
    local ba = Instance.new("ScreenGui")
    local ca = Instance.new("TextLabel")
    local da = Instance.new("Frame")
    local _b = Instance.new("TextLabel")
    local ab = Instance.new("TextLabel")

    ba.Parent = game.CoreGui
    ba.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

    ca.Parent = ba
    ca.Active = true
    ca.BackgroundColor3 = Color3.new(0.176471, 0.176471, 0.176471)
    ca.Draggable = true
    ca.Position = UDim2.new(0.698610067, 0, 0.098096624, 0)
    ca.Size = UDim2.new(0, 370, 0, 52)
    ca.Font = Enum.Font.SourceSansSemibold
    ca.Text = "Anti Afk"
    ca.TextColor3 = Color3.new(0, 1, 1)
    ca.TextSize = 22

    da.Parent = ca
    da.BackgroundColor3 = Color3.new(0.196078, 0.196078, 0.196078)
    da.Position = UDim2.new(0, 0, 1.0192306, 0)
    da.Size = UDim2.new(0, 370, 0, 107)

    _b.Parent = da
    _b.BackgroundColor3 = Color3.new(0.176471, 0.176471, 0.176471)
    _b.Position = UDim2.new(0, 0, 0.800455689, 0)
    _b.Size = UDim2.new(0, 370, 0, 21)
    _b.Font = Enum.Font.Arial
    _b.Text = "Made by luca#5432"
    _b.TextColor3 = Color3.new(0, 1, 1)
    _b.TextSize = 20

    ab.Parent = da
    ab.BackgroundColor3 = Color3.new(0.176471, 0.176471, 0.176471)
    ab.Position = UDim2.new(0, 0, 0.158377, 0)
    ab.Size = UDim2.new(0, 370, 0, 44)
    ab.Font = Enum.Font.ArialBold
    ab.Text = "Status: Active"
    ab.TextColor3 = Color3.new(0, 1, 1)
    ab.TextSize = 20

    local bb = game:GetService("VirtualUser")
    game:GetService("Players").LocalPlayer.Idled:Connect(function()
        bb:CaptureController()
        bb:ClickButton2(Vector2.new())
        ab.Text = "Roblox tried kicking you, but I didnâ€™t let them!"
        wait(2)
        ab.Text = "Status: Active"
    end)
end)

-- Destroy Ad teleport Button
Maintab:AddButton("Destroy Ad teleport", function()
    local part = workspace:FindFirstChild("RobloxForwardPortals")
    if part then
        part:Destroy()
        print("Part 'RobloxForwardPortals' has been destroyed.")
    else
        print("Part 'RobloxForwardPortals' not found.")
    end
end)




-- Brawl Things
local folder3 = Maintab:AddFolder("Brawl")

-- God Mode Toggle
folder3:AddSwitch("God Mode (Brawl)", function(State)
    godModeToggle = State
    if godModeToggle then
        task.spawn(function()
            while godModeToggle do
                local args = { [1] = "joinBrawl" }
                game:GetService("ReplicatedStorage"):WaitForChild("rEvents"):WaitForChild("brawlEvent"):FireServer(unpack(args))
                task.wait(0)  -- Repeat the event every 0 seconds
            end
        end)
    end
end)

-- Auto Join Brawl
folder3:AddSwitch("Auto Join Brawl", function(State)
    godModeToggle = State
    if godModeToggle then
        task.spawn(function()
            while godModeToggle do
                local args = { [1] = "joinBrawl" }
                game:GetService("ReplicatedStorage"):WaitForChild("rEvents"):WaitForChild("brawlEvent"):FireServer(unpack(args))
                task.wait(2)  -- Repeat the event every 2 seconds
            end
        end)
    end
end)

Maintab:AddLabel("Scripts Hub:")
Maintab:AddButton("Infinite yield",function()
	loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
end)

Maintab:AddButton("Dex Eplorer",function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/AhmadV99/Main/refs/heads/main/Dex-Explorer"))()
end)

Maintab:AddButton("Chat Spy",function()
	loadstring(game:HttpGet('https://raw.githubusercontent.com/doIIa/Script/refs/heads/master/ChatSpy.lua'))()
end)

Maintab:AddButton("Chat Bypass",function()
	loadstring(game:HttpGet('https://raw.githubusercontent.com/CrystalDMC/roblox-chat-bypass/refs/heads/main/script.lua'))()
end)

Maintab:AddButton("Permanent shiftlock",function()
	loadstring(game:HttpGet('https://pastebin.com/raw/CjNsnSDy'))()
end)

-- Auto Farm Tab
local AutoFarm = window:AddTab("Auto Farm")

AutoFarm:AddLabel("Reps")

local switch = AutoFarm:AddSwitch("Auto Farm", function(bool)
    local shouldRun = bool  -- Set the flag based on the toggle state

    -- Only start running the loop if the toggle is on
    if bool then
        while shouldRun do
            local args = { [1] = "rep" }

            -- Fire the muscle event on the server
            game:GetService("Players").LocalPlayer:WaitForChild("muscleEvent"):FireServer(unpack(args))

            -- Wait for 0.1 seconds before firing again
            wait(0.1)
            
            -- Check if the toggle was turned off
            shouldRun = bool
        end
    end
end)


AutoFarm:AddLabel("Tools")

local player = game.Players.LocalPlayer
local playerName = player.Name

-- Function to handle the usage of any tool with no animation
local function useTool(toolName, eventName)
    local tool = player.Backpack:FindFirstChild(toolName) or game.Workspace:FindFirstChild(playerName):FindFirstChild(toolName)

    if tool then
        if tool.Parent ~= game.Workspace:FindFirstChild(playerName) then
            tool.Parent = game.Workspace:FindFirstChild(playerName) -- Equip the tool
        end
        
        -- Fire event to use the tool without animation
        game.Players.LocalPlayer.muscleEvent:FireServer(eventName, "rightHand")
        game.Players.LocalPlayer.muscleEvent:FireServer(eventName, "leftHand")

        -- Disable animation (adjust as needed for your specific game)
        game.Players.LocalPlayer.Character:FindFirstChild("Humanoid"):SetStateEnabled(Enum.HumanoidStateType.Physics, false)

        wait() -- Adjust delay as needed
    else
        warn(toolName .. " tool not found")
    end
end

-- Auto Weight Toggle
local switchWeight = AutoFarm:AddSwitch("Auto Weight", function(bool)
    _G.autoWeightUse = bool

    if bool then
        while _G.autoWeightUse do
            useTool("Weight", "useWeight")  -- Use the weight tool
        end
    else
        game.Players.LocalPlayer.Character:FindFirstChild("Humanoid"):SetStateEnabled(Enum.HumanoidStateType.Physics, true)
        _G.autoWeightUse = false
    end
end)

-- Auto Pushups Toggle
local switchPushups = AutoFarm:AddSwitch("Auto Pushups", function(bool)
    _G.autoPushupsUse = bool

    if bool then
        while _G.autoPushupsUse do
            useTool("Pushups", "usePushups")  -- Use the pushups tool
        end
    else
        game.Players.LocalPlayer.Character:FindFirstChild("Humanoid"):SetStateEnabled(Enum.HumanoidStateType.Physics, true)
        _G.autoPushupsUse = false
    end
end)

-- Auto Handstands Toggle
local switchHandstands = AutoFarm:AddSwitch("Auto Handstands", function(bool)
    _G.autoHandstandsUse = bool

    if bool then
        while _G.autoHandstandsUse do
            useTool("Handstands", "useHandstands")  -- Use the handstands tool
        end
    else
        game.Players.LocalPlayer.Character:FindFirstChild("Humanoid"):SetStateEnabled(Enum.HumanoidStateType.Physics, true)
        _G.autoHandstandsUse = false
    end
end)

-- Auto Situps Toggle
local switchSitups = AutoFarm:AddSwitch("Auto Situps", function(bool)
    _G.autoSitupsUse = bool

    if bool then
        while _G.autoSitupsUse do
            useTool("Situps", "useSitups")  -- Use the situps tool
        end
    else
        game.Players.LocalPlayer.Character:FindFirstChild("Humanoid"):SetStateEnabled(Enum.HumanoidStateType.Physics, true)
        _G.autoSitupsUse = false
    end
end)

local AutoEggs = window:AddTab("Auto Eggs") -- Create the tab

local selectedCrystal = "Galaxy Oracle Crystal" -- Default selected crystal
local autoCrystalRunning = false

-- Dropdown for selecting a crystal
local dropdown = AutoEggs:AddDropdown("Select Crystal", function(text)
    selectedCrystal = text  -- Store selected crystal name
    print("Selected Crystal: " .. text)
end)

-- Add crystal options to dropdown
local crystalNames = {
    "Blue Crystal", "Green Crystal", "Frozen Crystal", "Mythical Crystal",
    "Inferno Crystal", "Legends Crystal", "Muscle Elite Crystal",
    "Galaxy Oracle Crystal", "Sky Eclipse Crystal", "Jungle Crystal"
}

for _, name in ipairs(crystalNames) do
    dropdown:Add(name)
end

-- Function to auto open selected crystal
local function autoOpenCrystal()
    while autoCrystalRunning do
        local args = {
            [1] = "openCrystal",
            [2] = selectedCrystal
        }

        game:GetService("ReplicatedStorage"):WaitForChild("rEvents"):WaitForChild("openCrystalRemote"):InvokeServer(unpack(args))
        wait(0.1) -- 0.1-second delay before opening again
    end
end

-- Toggle switch
local switch = AutoEggs:AddSwitch("Auto Crystal", function(state)
    autoCrystalRunning = state

    if autoCrystalRunning then
        spawn(autoOpenCrystal) -- Start auto-opening crystals
    end
end)

local Rebirth = window:AddTab("Auto Rebirthing") -- Create the tab
Rebirth:AddLabel("Rebirth Features:")
local rebirthCount = 0 -- Variable to store the desired number of rebirths

Rebirth:AddSwitch("Auto Rebirth", function(state)
    if state then
        -- Start a coroutine to run the rebirth request continuously
        coroutine.wrap(function()
            while state do
                local args = {
                    [1] = "rebirthRequest"
                }
                -- Trigger the rebirth event
                game:GetService("ReplicatedStorage"):WaitForChild("rEvents"):WaitForChild("rebirthRemote"):InvokeServer(unpack(args))
                wait(1)  -- Wait 1 second before sending another rebirth request (adjustable)
            end
        end)()
    end
end)

-- Textbox to input the amount of rebirths
Rebirth:AddTextBox("Amount of rebirth you wanna do", function(text)
    rebirthCount = tonumber(text) or 0  -- Convert input to a number, default to 0 if invalid
end)

-- Toggle to auto rebirth until reaching the specified amount
Rebirth:AddSwitch("Auto rebirth until reach amount", function(state)
    if state then
        -- Start a coroutine to rebirth the specified amount of times
        coroutine.wrap(function()
            local count = 0
            while state and count < rebirthCount do
                local args = {
                    [1] = "rebirthRequest"
                }
                -- Trigger the rebirth event
                game:GetService("ReplicatedStorage"):WaitForChild("rEvents"):WaitForChild("rebirthRemote"):InvokeServer(unpack(args))
                count = count + 1
                wait(1)  -- Wait 1 second before sending the next rebirth request (adjustable)
            end
        end)()
    end
end)

-- New Toggle: Auto rebirth + set size 2 + Auto teleport to muscle king
Rebirth:AddSwitch("Auto rebirth+set size 2+Auto teleport muscle king", function(state)
    if state then
        -- Start the coroutine for infinite rebirths, teleport, and size change
        coroutine.wrap(function()
            while state do
                -- Rebirth event
                local args = {
                    [1] = "rebirthRequest"
                }
                game:GetService("ReplicatedStorage"):WaitForChild("rEvents"):WaitForChild("rebirthRemote"):InvokeServer(unpack(args))

                -- Set size to 2
                local sizeArgs = {
                    [1] = "changeSize",
                    [2] = "2"
                }
                game:GetService("ReplicatedStorage"):WaitForChild("rEvents"):WaitForChild("sizeRemote"):InvokeServer(unpack(sizeArgs))

                -- Teleport to the given position
                local muscleKingPosition = CFrame.new(-8768.96875, 9.1000309, -5863.37402, 1, 0, 0, 0, 1, 0, 0, 0, 1)
                game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(muscleKingPosition)

                wait(1)  -- Delay before doing the next action (adjustable)
            end
        end)()
    end
end)






local Killing = window:AddTab("Killing")
local whitelistedPlayers = {}
local targetName = ""
local killPlayersActive = false
local autoKillActive = false
local autoEquipPunchActive = false
local killStartTime = 0
local killTimeLabel
local punchTool
local autoPunchanim = false

Killing:AddLabel("Whitelist")
Killing:AddTextBox("Whitelist Players", function(text)
    table.insert(whitelistedPlayers, text)
end)

Killing:AddTextBox("Unwhitelist Players", function(text)
    for i, player in ipairs(whitelistedPlayers) do
        if player == text then
            table.remove(whitelistedPlayers, i)
            break
        end
    end
end)

Killing:AddLabel("Auto Killing")

local function restoreVisibility()
    for _, otherPlayer in pairs(game.Players:GetChildren()) do
        local character = game.Workspace:FindFirstChild(otherPlayer.Name)
        if character then
            for _, part in pairs(character:GetChildren()) do
                if part:IsA("BasePart") or part:IsA("MeshPart") then
                    part.Transparency = 0
                    part.CanCollide = true
                end
            end
            for _, accessory in pairs(character:GetChildren()) do
                if accessory:IsA("Accessory") or accessory:IsA("Hat") then
                    if accessory:FindFirstChild("Handle") then
                        accessory.Handle.Transparency = 0
                    end
                end
            end
        end
    end
end

local function equipPunchTool()
    local player = game.Players.LocalPlayer
    local playerName = player.Name
    punchTool = player.Backpack:FindFirstChild("Punch") or game.Workspace:FindFirstChild(playerName):FindFirstChild("Punch")
    if punchTool and punchTool.Parent ~= game.Workspace:FindFirstChild(playerName) then
        punchTool.Parent = game.Workspace:FindFirstChild(playerName)
    end
end

local function punchAction()
    local player = game.Players.LocalPlayer
    player.muscleEvent:FireServer("punch", "rightHand")
    player.muscleEvent:FireServer("punch", "leftHand")
end

local function makeInvisible(character)
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") or part:IsA("MeshPart") then
            part.Transparency = 1
            part.CanCollide = false
        end
    end
    for _, accessory in pairs(character:GetChildren()) do
        if accessory:IsA("Accessory") or accessory:IsA("Hat") then
            if accessory:FindFirstChild("Handle") then
                accessory.Handle.Transparency = 1
            end
        end
    end
end

Killing:AddSwitch("Auto Kill", function(state)
    autoKillActive = state
    if autoKillActive then
        coroutine.wrap(function()
            local player = game.Players.LocalPlayer
            local playerName = player.Name
            while autoKillActive do
                equipPunchTool()
                punchAction()
                for _, otherPlayer in pairs(game.Players:GetChildren()) do
                    if otherPlayer.Name ~= playerName and not table.find(whitelistedPlayers, otherPlayer.Name) then
                        local character = game.Workspace:FindFirstChild(otherPlayer.Name)
                        local localCharacter = game.Workspace:FindFirstChild(playerName)
                        if character and localCharacter then
                            local rightHand = localCharacter:FindFirstChild("RightHand")
                            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                            if rightHand and humanoidRootPart then
                                humanoidRootPart.CFrame = rightHand.CFrame
                                makeInvisible(character)
                            end
                        end
                    end
                end
                wait(0.1)
            end
        end)()
    else
        restoreVisibility()
    end
end)

Killing:AddSwitch("Auto Equip Punch", function(state)
    autoEquipPunchActive = state
    if autoEquipPunchActive then
        coroutine.wrap(function()
            while autoEquipPunchActive do
                equipPunchTool()
                wait(0.1)
            end
        end)()
    end
end)

Killing:AddLabel("Targeting")

-- Create Dropdown for selecting a player
local dropdown = Killing:AddDropdown("Select Player", function(text)
    targetName = text
    print(text .. " selected!")
end)

-- Dynamically add player names to the dropdown
for _, player in ipairs(game.Players:GetPlayers()) do
    if player.Name ~= game.Players.LocalPlayer.Name then  -- Exclude the local player
        dropdown:Add(player.Name)  -- Add each player's name to the dropdown
    end
end

Killing:AddSwitch("Kill Players", function(state)
    killPlayersActive = state
    if killPlayersActive then
        killStartTime = 0
        
        -- Start the kill timer coroutine
        coroutine.wrap(function()
            while killPlayersActive do
                wait(1)  -- Wait for 1 second
                killStartTime = killStartTime + 1
                local minutes = math.floor(killStartTime / 60)
                local seconds = killStartTime % 60
                -- Update the label text every second
                killTimeLabel:SetText(string.format("Amount Of Time Killing Player: %02d:%02d", minutes, seconds))
            end
        end)()

        coroutine.wrap(function()
            local player = game.Players.LocalPlayer
            local playerName = player.Name
            while killPlayersActive do
                equipPunchTool()
                punchAction()
                if targetName ~= "" then
                    for _, otherPlayer in pairs(game.Players:GetChildren()) do
                        if otherPlayer.Name == targetName then
                            local character = game.Workspace:FindFirstChild(otherPlayer.Name)
                            local localCharacter = game.Workspace:FindFirstChild(playerName)
                            if character and localCharacter then
                                local rightHand = localCharacter:FindFirstChild("RightHand")
                                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                                if rightHand and humanoidRootPart then
                                    humanoidRootPart.CFrame = rightHand.CFrame
                                    makeInvisible(character)
                                end
                            end
                        end
                    end
                end
                wait(0.1)
            end
        end)()
    else
        restoreVisibility()
        killTimeLabel:SetText("Amount Of Time Killing Player: 00:00")
    end
end)

-- Label for displaying the kill timer
killTimeLabel = Killing:AddLabel("Amount Of Time Killing Player: 00:00")

Killing:AddSwitch("Auto Punch", function(state)
    local player = game.Players.LocalPlayer
    local playerName = player.Name
    if state then
        while state do
            equipPunchTool()
            punchAction()
            wait(0.1)
        end
    else
        print("Auto Punch is turned off")
    end
end)

Killing:AddSwitch("Auto Punch [No Animation]", function(state)
    autoPunchanim = state
    if autoPunchanim then
        while autoPunchanim do
            equipPunchTool()
            punchAction()
            wait(0.1)
        end
    else
        print("Auto Punch [No Animation] is turned off")
    end
end)

-- Teleport Tab
local Teleport = window:AddTab("Teleport")

local locations = {
    {"Beach", Vector3.new(-11, 5, -178)},
    {"Legends Island", Vector3.new(4603, 989, -3898)},
    {"Muscle King Gym", Vector3.new(-8626, 15, -5730)},
    {"Tiny Island", Vector3.new(-38, 5, 1884)},
    {"Secret Location", Vector3.new(-2596, -1, 5738)},
    {"Inferno Island", Vector3.new(-6759, 5, -1285)},
    {"Frost Island", Vector3.new(-2623, 5, -409)},
    {"Mythical Island", Vector3.new(2251, 5, 1073)}
}

-- Iterate over each location and create a button for it
for _, location in ipairs(locations) do
    local name, position = location[1], location[2]
    Teleport:AddButton(name, function()
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(CFrame.new(position))
    end)
end

                             
        
-- View Stats Tab
local Playertab = window:AddTab("Player")

Playertab:AddLabel("Spying")

local selectedPlayerName = "" -- Variable to store player name

-- Switch for spying on a player
local switch = Playertab:AddSwitch("Spy Player", function(bool)
    if bool then
        -- Find the player in the game
        local player = game.Players:FindFirstChild(selectedPlayerName)
        
        if player and player.Character then
            local character = player.Character:FindFirstChild("HumanoidRootPart")
            if character then
                local camera = game.Workspace.CurrentCamera
                camera.CameraSubject = character -- Follow the player
                camera.CameraType = Enum.CameraType.Follow -- Ensures smooth tracking
            end
        else
            print("Player not found or not loaded.")
        end
    else
        -- Reset the camera back to the default view
        local camera = game.Workspace.CurrentCamera
        camera.CameraSubject = game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") -- Focus on the local player
        camera.CameraType = Enum.CameraType.Custom
    end
end)

-- Textbox setup to capture player name
Playertab:AddTextBox("Player Name", function(text)
    if text and text ~= "" then
        selectedPlayerName = text -- Store the inputted player name
    end
end)


Playertab:AddButton("Clear",function()
	-- Code here
end)

Playertab:AddButton("Teleport To Player", function()
    local localPlayer = game.Players.LocalPlayer -- Get the local player
    local character = localPlayer.Character -- Get the local player's character

    if selectedPlayerName and selectedPlayerName ~= "" then
        local targetPlayer = game.Players:FindFirstChild(selectedPlayerName) -- Find the target player
        
        if targetPlayer and targetPlayer.Character then
            local targetPosition = targetPlayer.Character:FindFirstChild("HumanoidRootPart") -- Get target's position
            
            if character and targetPosition then
                character:MoveTo(targetPosition.Position) -- Teleport the local player
            else
                print("Target player's HumanoidRootPart not found.")
            end
        else
            print("Player not found or not loaded.")
        end
    else
        print("No player selected.")
    end
end)

Playertab:AddLabel("View Stats")



local playerData = {}
local currentSelectedPlayer = nil
local notFoundLabel = nil
local selectedPlayerName = nil

-- Helper function to abbreviate large numbers
local function abbreviateNumber(value)
    if value >= 1e15 then
        return string.format("%.1fQa", value / 1e15)
    elseif value >= 1e12 then
        return string.format("%.1fT", value / 1e12)
    elseif value >= 1e9 then
        return string.format("%.1fB", value / 1e9)
    elseif value >= 1e6 then
        return string.format("%.1fM", value / 1e6)
    elseif value >= 1e3 then
        return string.format("%.1fK", value / 1e3)
    else
        return tostring(value)
    end
end

-- Function to create labels for the selected player's stats
local function createPlayerLabels(player)
    local playerName = player.Name
    local leaderstats = player:FindFirstChild("leaderstats")
    local equippedPets = player:FindFirstChild("equippedPets")
    local ownedGamepasses = player:FindFirstChild("ownedGamepasses")

    -- Ensure leaderstats is present
    if not leaderstats then
        return
    end

    -- Create labels for stats
    local labels = {
        StrengthLabel = Playertab:AddLabel("Strength: " .. abbreviateNumber(leaderstats.Strength and leaderstats.Strength.Value or 0)),
        DurabilityLabel = Playertab:AddLabel("Durability: " .. abbreviateNumber(player.Durability and player.Durability.Value or 0)),
        KillsLabel = Playertabab:AddLabel("Kills: " .. abbreviateNumber(leaderstats.Kills and leaderstats.Kills.Value or 0)),
        BrawlsLabel = Playertab:AddLabel("Brawls: " .. abbreviateNumber(leaderstats.Brawls and leaderstats.Brawls.Value or 0)),
        AgilityLabel = Playeryab:AddLabel("Agility: " .. abbreviateNumber(player.Agility and player.Agility.Value or 0)),
        EvilKarmaLabel = Playertab:AddLabel("evilKarma: " .. abbreviateNumber(player.evilKarma and player.evilKarma.Value or 0)),
        GoodKarmaLabel = Playertab:AddLabel("goodKarma: " .. abbreviateNumber(player.goodKarma and player.goodKarma.Value or 0)),
        MapLabel = Playertab:AddLabel("Map: " .. (player.currentMap and player.currentMap.Value or "N/A")),
        KingTimeLabel = Playertab:AddLabel("KingTime: " .. abbreviateNumber(player.muscleKingTime and player.muscleKingTime.Value or 0)),
        PremiumLabel = Playertab:AddLabel("Premium: " .. (player.MembershipType == Enum.MembershipType.Premium and "true" or "false")),
    }

    -- Add pet labels (ensure equippedPets exists)
    if equippedPets then
        for i = 1, 5 do
            local petValue = equippedPets:FindFirstChild("pet" .. i) and equippedPets["pet" .. i].Value or "N/A"
            labels["Pet" .. i .. "Label"] = Playertab:AddLabel("Pet" .. i .. ": " .. tostring(petValue))
        end
    end

    -- Add owned gamepasses (ensure ownedGamepasses exists)
    local gamepassList = {}
    if ownedGamepasses then
        for _, gamepass in ipairs(ownedGamepasses:GetChildren()) do
            table.insert(gamepassList, gamepass.Name)
        end
    end

    local gamepassesText = #gamepassList > 0 and table.concat(gamepassList, ", ") or "N/A"
    labels.GamepassesLabel = Playertab:AddLabel("ownedGamepasses: " .. gamepassesText)

    playerData[playerName] = labels

    -- Connect value change events to update the labels
    if leaderstats.Kills then
        leaderstats.Kills.Changed:Connect(function()
            labels.KillsLabel.Text = "Kills: " .. abbreviateNumber(leaderstats.Kills.Value or 0)
        end)
    end

    if leaderstats.Strength then
        leaderstats.Strength.Changed:Connect(function()
            labels.StrengthLabel.Text = "Strength: " .. abbreviateNumber(leaderstats.Strength.Value or 0)
        end)
    end

    if leaderstats.Brawls then
        leaderstats.Brawls.Changed:Connect(function()
            labels.BrawlsLabel.Text = "Brawls: " .. abbreviateNumber(leaderstats.Brawls.Value or 0)
        end)
    end

    if player.Durability then
        player.Durability.Changed:Connect(function()
            labels.DurabilityLabel.Text = "Durability: " .. abbreviateNumber(player.Durability.Value or 0)
        end)
    end

    if player.Agility then
        player.Agility.Changed:Connect(function()
            labels.AgilityLabel.Text = "Agility: " .. abbreviateNumber(player.Agility.Value or 0)
        end)
    end

    if player.evilKarma then
        player.evilKarma.Changed:Connect(function()
            labels.EvilKarmaLabel.Text = "evilKarma: " .. abbreviateNumber(player.evilKarma.Value or 0)
        end)
    end

    if player.goodKarma then
        player.goodKarma.Changed:Connect(function()
            labels.GoodKarmaLabel.Text = "goodKarma: " .. abbreviateNumber(player.goodKarma.Value or 0)
        end)
    end
end

-- Function to remove player labels (cleanup)
local function removePlayerLabels(playerName)
    if playerData[playerName] then
        for _, label in pairs(playerData[playerName]) do
            label:Remove()
        end
        playerData[playerName] = nil
    end
end

-- Adding a textbox for player name input
local textbox = Playertab:AddTextBox("Player Name", function(playerName)
    selectedPlayerName = playerName
    if notFoundLabel then
        notFoundLabel:Remove()
        notFoundLabel = nil
    end

    local player = game.Players:FindFirstChild(playerName)
    if player then
        if currentSelectedPlayer then
            removePlayerLabels(currentSelectedPlayer)
        end
        createPlayerLabels(player)
        currentSelectedPlayer = playerName
    else
        notFoundLabel = Playertab:AddLabel("Player not found!")
    end
end)

-- Server Tab
local Server = window:AddTab("Server")

-- Initialize the time spent variable
local timeSpent = 0

-- Create the label (only once)
local label = Server:AddLabel("Amount Of Time Spent In Server: 0 weeks, 0 days, 0 hours, 0 minutes, 0 seconds")

-- Function to convert total seconds into weeks, days, hours, minutes, and seconds
local function convertTime(seconds)
    local weeks = math.floor(seconds / (7 * 24 * 3600))
    seconds = seconds - weeks * 7 * 24 * 3600
    local days = math.floor(seconds / (24 * 3600))
    seconds = seconds - days * 24 * 3600
    local hours = math.floor(seconds / 3600)
    seconds = seconds - hours * 3600
    local minutes = math.floor(seconds / 60)
    seconds = seconds - minutes * 60
    return weeks, days, hours, minutes, seconds
end

-- Function to update the label's text
local function updateLabel()
    -- Convert the total time spent into weeks, days, hours, minutes, and seconds
    local weeks, days, hours, minutes, seconds = convertTime(timeSpent)

    -- Format the time into a readable string
    local timeString = string.format(
        "Amount Of Time Spent In Server: %d weeks, %d days, %d hours, %d minutes, %d seconds",
        weeks, days, hours, minutes, seconds
    )

    -- Update the text of the label
    label.Text = timeString
end

-- Start a loop to update the label every second
spawn(function()
    while true do
        wait(1)  -- Wait for 1 second before updating again
        timeSpent = timeSpent + 1  -- Increment the time spent by 1 second
        updateLabel()  -- Update the label with the new time
    end
end)

-- Helper function to abbreviate large numbers
local function abbreviateNumber(value)
    if value >= 1e15 then
        return string.format("%.1fQa", value / 1e15)
    elseif value >= 1e12 then
        return string.format("%.1fT", value / 1e12)
    elseif value >= 1e9 then
        return string.format("%.1fB", value / 1e9)
    elseif value >= 1e6 then
        return string.format("%.1fM", value / 1e6)
    elseif value >= 1e3 then
        return string.format("%.1fK", value / 1e3)
    else
        return tostring(value)
    end
end

-- Function to create labels for the local player's stats
local function createMyLabels()
    local player = game.Players.LocalPlayer
    if not player then return end

    local leaderstats = player:FindFirstChild("leaderstats")
    if not leaderstats then return end

    -- Create labels for the stats we want to track
    local labels = {
        StrengthGainedLabel = Server:AddLabel("Amount of strength gained in this server: 0"),
        DurabilityGainedLabel = Server:AddLabel("Amount of durability gained in this server: 0"),
        AgilityGainedLabel = Server:AddLabel("Amount of agility gained in this server: 0"),
        KillsGainedLabel = Server:AddLabel("Amount of kills gained in this server: 0"),
    }

    -- Assume playerData is already defined in your main script
    playerData[player.Name] = labels

    -- Capture the initial values when you join the server
    local initialStrength = leaderstats.Strength and leaderstats.Strength.Value or 0
    local initialDurability = player.Durability and player.Durability.Value or 0
    local initialAgility = player.Agility and player.Agility.Value or 0
    local initialKills = leaderstats.Kills and leaderstats.Kills.Value or 0

    -- Function to update labels based on stat changes
    local function updateLabels()
        local strengthGained = leaderstats.Strength and leaderstats.Strength.Value - initialStrength or 0
        local durabilityGained = player.Durability and player.Durability.Value - initialDurability or 0
        local agilityGained = player.Agility and player.Agility.Value - initialAgility or 0
        local killsGained = leaderstats.Kills and leaderstats.Kills.Value - initialKills or 0

        labels.StrengthGainedLabel.Text = "Amount of strength gained in this server: " .. abbreviateNumber(strengthGained)
        labels.DurabilityGainedLabel.Text = "Amount of durability gained in this server: " .. abbreviateNumber(durabilityGained)
        labels.AgilityGainedLabel.Text = "Amount of agility gained in this server: " .. abbreviateNumber(agilityGained)
        labels.KillsGainedLabel.Text = "Amount of kills gained in this server: " .. abbreviateNumber(killsGained)
    end

    -- Connect change events to update the labels when your stats change
    if leaderstats.Strength then
        leaderstats.Strength.Changed:Connect(updateLabels)
    end

    if player.Durability then
        player.Durability.Changed:Connect(updateLabels)
    end

    if player.Agility then
        player.Agility.Changed:Connect(updateLabels)
    end

    if leaderstats.Kills then
        leaderstats.Kills.Changed:Connect(updateLabels)
    end

    -- Initial update
    updateLabels()
end

-- Call the function to start tracking your own stats
createMyLabels()

-- The credit tab
local Credit = window:AddTab("Credit")
Credit:AddLabel("Script Made By Encrypted")
Credit:AddLabel("Best friends: CwmoKai, Aabis, blackyy, Ahmad")
Credit:AddLabel("Big thanks to KLN, who was the biggest victim during testing the script, much respect to him <3")
Credit:AddLabel("Discord Server: https://discord.gg/fzKFQ2vw")

-- Show the window
window:Show()
